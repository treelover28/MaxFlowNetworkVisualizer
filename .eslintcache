[{"/home/khai/Documents/school_stuff/2020_fall/advance_algo/MaxFlowVisualizer/max-flow-visualizer/src/App.js":"1","/home/khai/Documents/school_stuff/2020_fall/advance_algo/MaxFlowVisualizer/max-flow-visualizer/src/index.js":"2","/home/khai/Documents/school_stuff/2020_fall/advance_algo/MaxFlowVisualizer/max-flow-visualizer/src/components/Board.js":"3","/home/khai/Documents/school_stuff/2020_fall/advance_algo/MaxFlowVisualizer/max-flow-visualizer/src/LogicalClasses/Node.js":"4","/home/khai/Documents/school_stuff/2020_fall/advance_algo/MaxFlowVisualizer/max-flow-visualizer/src/reportWebVitals.js":"5","/home/khai/Documents/school_stuff/2020_fall/advance_algo/MaxFlowVisualizer/max-flow-visualizer/src/LogicalClasses/Misc.js":"6","/home/khai/Documents/school_stuff/2020_fall/advance_algo/MaxFlowVisualizer/max-flow-visualizer/src/LogicalClasses/GridPathFinder.js":"7","/home/khai/Documents/school_stuff/2020_fall/advance_algo/MaxFlowVisualizer/max-flow-visualizer/src/LogicalClasses/GraphPathFinder.js":"8","/home/khai/Documents/school_stuff/2020_fall/advance_algo/MaxFlowVisualizer/max-flow-visualizer/src/LogicalClasses/NetworkFlow.js":"9"},{"size":279,"mtime":1606773582822,"results":"10","hashOfConfig":"11"},{"size":500,"mtime":1606525875336,"results":"12","hashOfConfig":"11"},{"size":12455,"mtime":1606941441308,"results":"13","hashOfConfig":"11"},{"size":292,"mtime":1606885365752,"results":"14","hashOfConfig":"11"},{"size":362,"mtime":1606525875336,"results":"15","hashOfConfig":"11"},{"size":839,"mtime":1606905192220,"results":"16","hashOfConfig":"11"},{"size":9650,"mtime":1606898145522,"results":"17","hashOfConfig":"11"},{"size":3725,"mtime":1606941445495,"results":"18","hashOfConfig":"11"},{"size":3475,"mtime":1606940503128,"results":"19","hashOfConfig":"11"},{"filePath":"20","messages":"21","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},"yjnb17",{"filePath":"23","messages":"24","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"25"},{"filePath":"26","messages":"27","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"28","messages":"29","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"30","messages":"31","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},{"filePath":"33","messages":"34","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"35","messages":"36","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"37"},{"filePath":"38","messages":"39","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"40","messages":"41","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},"/home/khai/Documents/school_stuff/2020_fall/advance_algo/MaxFlowVisualizer/max-flow-visualizer/src/App.js",[],["42","43"],"/home/khai/Documents/school_stuff/2020_fall/advance_algo/MaxFlowVisualizer/max-flow-visualizer/src/index.js",[],["44","45"],"/home/khai/Documents/school_stuff/2020_fall/advance_algo/MaxFlowVisualizer/max-flow-visualizer/src/components/Board.js",[],"/home/khai/Documents/school_stuff/2020_fall/advance_algo/MaxFlowVisualizer/max-flow-visualizer/src/LogicalClasses/Node.js",[],"/home/khai/Documents/school_stuff/2020_fall/advance_algo/MaxFlowVisualizer/max-flow-visualizer/src/reportWebVitals.js",[],["46","47"],"/home/khai/Documents/school_stuff/2020_fall/advance_algo/MaxFlowVisualizer/max-flow-visualizer/src/LogicalClasses/Misc.js",[],"/home/khai/Documents/school_stuff/2020_fall/advance_algo/MaxFlowVisualizer/max-flow-visualizer/src/LogicalClasses/GridPathFinder.js",["48","49"],"import Node from \"./Node\";\nimport {getRandomColor, nodeParser, nodeEqual} from \"./Misc\";\nimport _ from \"lodash\";\n\n\nclass GridPathFinder {\n    constructor(gridArray,source, sink, networkDefinition,strategy) {\n        this.gridArray = gridArray;\n        this.gridMaxX = gridArray.length;\n        this.gridMaxY = gridArray[0].length;\n        this.source = source;\n        this.sink = sink\n        this.networkDefinition = networkDefinition;\n        this.strategy = strategy.trim().toLowerCase();\n        this.allowedStrategies = [\"bfs\", \"dfs\"];\n    }\n\n    getGridWithPaths = () => {\n        // process network definition to get sourceTargetDict\n        let graph = this.processNetworkDefinition();\n        console.log(graph);\n        // depending on this.strategy, dispatch to different function \n        if (this.allowedStrategies.includes(this.strategy)) {\n            return this.findPathsOnGrid(this.gridArray, graph, this.strategy);\n        } else {\n            return \"Unknown Pathfinding strategy\";\n        }\n\n    }\n\n    processNetworkDefinition = () => {\n        let networkDef = this.networkDefinition;\n\n        let parsedSource = nodeParser(this.source, this.gridMaxX, this.gridMaxY);\n        let parsedSink = nodeParser(this.sink, this.gridMaxX, this.gridMaxY); \n\n        // if source and sink are not specified, or is in invalid format, return error message\n        if (typeof parsedSource === \"string\" || typeof parsedSink === \"string\") {\n            return \"Error: Invalid Source or Sink node format. Check if your coordinates are in correct format and they are within the dimension of the grid.\";\n        }\n\n        let edgeDefinitions = networkDef.split(\";\").filter(x=>x);\n        // map to keep track of {NodeA : [(NodeB, capacity), (NodeC, capacity) ...]}\n        let graph = new Map();\n        \n        let notHasSource = true;\n        let notHasSink = true;\n\n        edgeDefinitions.forEach(edgeDef => {\n            let edgeDefArr = edgeDef.split(\"->\").filter(x=>x);\n            let serverA = edgeDefArr[0].trim();\n            let capacity = +edgeDefArr[1].trim();\n            let serverB = edgeDefArr[2].trim();\n\n            let parsedA = nodeParser(serverA, this.gridMaxX, this.gridMaxY);\n            let parsedB = nodeParser(serverB, this.gridMaxX, this.gridMaxY);\n\n            if (typeof parsedA === \"string\" || typeof parsedB === \"string\") {\n                let err = \"Error: Invalid network node format. Check if your coordinates are in correct format and they are within the dimension of the grid.\";\n                alert(err);\n                return err;\n            }\n            \n            // if network doesn't have a source nor a sink, it trivially has a flow of 0! \n            if (serverA === this.source || serverB === this.source) {\n                notHasSource = false;\n            }\n            if (serverA === this.sink || serverB === this.sink) {\n                notHasSink = false;\n            }\n            \n            let edge = [serverB, capacity];\n            let currentEdgeList = graph.get(serverA);\n            if (currentEdgeList === undefined) {  \n                currentEdgeList = [edge];\n            } else {\n                currentEdgeList.push(edge);\n            }\n            graph.set(serverA, currentEdgeList);\n        })\n\n        if (notHasSource || notHasSink) {\n            let err = \"Error: Network doesn't have well-defined source or sink. This network trivially has a flow of 0\";\n            alert(err);\n            return err;\n        }\n        return graph;\n    }\n\n    findPathsOnGrid = (gridArray, graph, strategy) => {\n        let currNodeCoord = null;\n        let currNode = null;\n\n        if (typeof graph == \"string\") {\n            let err = \"Error! Not a valid network!\";\n            alert(err);\n            return err;\n        }\n        \n        // keeps track of paths from different sources to their destinations\n        let sourcesPathsList = new Map();\n\n        let parsedSource = nodeParser(this.source,this.gridMaxX,this.gridMaxY);\n        let parsedSink = nodeParser(this.sink,this.gridMaxX, this.gridMaxY);\n\n        for (const [curr, targets] of graph) {\n            let parsedCurr = nodeParser(curr, this.gridMaxX, this.gridMaxY);\n            \n            // add parseCurr to sourcesPathsList with an empty list of paths at first\n            sourcesPathsList.set(curr, []);\n\n            let randomColor = getRandomColor();\n            targets.forEach(target => {\n\n                let targetNode = target[0];\n                let parsedTargetNode = nodeParser(targetNode, this.gridMaxX, this.gridMaxY);\n                let capacity = +target[1];\n                let foundPath = this.pathFinderHelper(gridArray, curr, targetNode, strategy);\n                if (foundPath === \"No Path found\") {\n                    alert(\"No path found between \" + curr + \" and \" + targetNode);\n                    return \"Please redefine your network by spreading the nodes out further\";\n                }\n\n                // add new paths to map\n                let currPathsFromSourceList = sourcesPathsList.get(curr);\n                currPathsFromSourceList.push(_.cloneDeep(foundPath));\n                sourcesPathsList.set(curr, currPathsFromSourceList);\n\n                let i = 0;\n                while (foundPath.length !== 0) {\n                    currNodeCoord = foundPath.shift();\n                    currNode = gridArray[+currNodeCoord[0]][+currNodeCoord[1]]; \n                    // check if currNode is a source or a sink or none\n                    if (nodeEqual(currNodeCoord,parsedSource)) {\n                        currNode.isSource = true;\n                    } else if (nodeEqual(currNodeCoord,parsedSink)) {\n                        currNode.isSink = true;\n                    }\n\n                    if (currNode.type === \"connected-server\" || nodeEqual(currNodeCoord, parsedTargetNode) || nodeEqual(currNodeCoord, parsedCurr)) {\n                        currNode.type = \"connected-server\";\n                    }\n                    else {\n                        currNode.type = \"connection\";\n                        currNode.capacity = capacity;  \n                        currNode.color = randomColor;\n                    }\n                    // nodes from the same source gets the same color including the source itself but not the destination\n                    if (i === 0){\n                        currNode.color = randomColor;\n                    }\n                    i++; \n                }\n            })  \n        }\n        this.gridArray = gridArray;\n        \n        return [gridArray, sourcesPathsList]; \n    }\n\n\n\n    pathFinderHelper(gridArray, source, target, strategy) { \n        let fringe = [source] \n        // parse string representation of a Node to an object\n        let parsedSource = nodeParser(source, this.gridMaxX, this.gridMaxY);\n\n        let currX = +parsedSource[0];\n        let currY = +parsedSource[1];\n\n        // keep track of nodes we already visited\n        let visitedNodes = new Set();\n\n        let currNode;\n        // dictionary to keep track of BFS shortest path tree\n        let parent = new Map();\n\n        parent.set(source, null);\n        visitedNodes.add(source);\n\n        while (fringe.length !== 0) {\n            if (strategy === \"bfs\"){\n                // BFS\n                currNode = fringe.shift();\n            }\n            else {\n                // DFS \n                currNode = fringe.pop();\n            }\n            \n            let parsedNode = nodeParser(currNode, this.gridMaxX, this.gridMaxY);\n            \n            currX = +parsedNode[0];\n            currY = +parsedNode[1];\n            \n            if (currNode === target) {\n                break;\n            }\n            \n            let rightNode = \"(\" + (currX + 1) + \",\" + currY +\")\";\n            let leftNode = \"(\" + (currX  - 1) + \",\" + currY +\")\";\n            let topNode = \"(\" + (currX) + \",\" + (currY + 1) +\")\";\n            let botNode = \"(\" + (currX) + \",\" + (currY - 1) +\")\";\n\n            if ((currX+1) < gridArray.length && !visitedNodes.has(rightNode) && (gridArray[currX + 1][currY].type === \"empty\" || rightNode === target)) {\n                fringe.push(rightNode);\n                parent.set(rightNode, currNode);\n                visitedNodes.add(rightNode);\n            }\n            if ((currX-1) >= 0 && !visitedNodes.has(leftNode) && (gridArray[currX - 1][currY].type === \"empty\"  || leftNode === target)) {\n                fringe.push(leftNode);\n                parent.set(leftNode, currNode);\n                visitedNodes.add(leftNode);\n            }\n            if ((currY + 1) < gridArray[0].length && !visitedNodes.has(topNode) && (gridArray[currX][currY + 1].type === \"empty\"  || topNode === target)) {\n                fringe.push(topNode);\n                parent.set(topNode, currNode);\n                visitedNodes.add(topNode);\n            }\n            if ((currY - 1) >= 0 && !visitedNodes.has(botNode) && (gridArray[currX][currY - 1].type === \"empty\"  || botNode === target) ) {\n                fringe.push(botNode);\n                parent.set(botNode, currNode);\n                visitedNodes.add(botNode);\n\n            }    \n        }\n\n        if (currNode === target) {\n            let path = []\n            // change currNode back from object to its string representation\n            while(currNode !== null) {\n                console.log(\"travelling up!\");\n                path.unshift(nodeParser(currNode, this.gridMaxX, this.gridMaxY));\n                currNode = parent.get(currNode);\n            }\n            return path;\n        }\n        return \"No Path found\";\n    }\n}\n\nexport default GridPathFinder;","/home/khai/Documents/school_stuff/2020_fall/advance_algo/MaxFlowVisualizer/max-flow-visualizer/src/LogicalClasses/GraphPathFinder.js",["50"],"/home/khai/Documents/school_stuff/2020_fall/advance_algo/MaxFlowVisualizer/max-flow-visualizer/src/LogicalClasses/NetworkFlow.js",["51"],{"ruleId":"52","replacedBy":"53"},{"ruleId":"54","replacedBy":"55"},{"ruleId":"52","replacedBy":"56"},{"ruleId":"54","replacedBy":"57"},{"ruleId":"52","replacedBy":"58"},{"ruleId":"54","replacedBy":"59"},{"ruleId":"60","severity":1,"message":"61","line":1,"column":8,"nodeType":"62","messageId":"63","endLine":1,"endColumn":12},{"ruleId":"64","severity":1,"message":"65","line":113,"column":29,"nodeType":"66","messageId":"67","endLine":154,"endColumn":14},{"ruleId":"64","severity":1,"message":"68","line":49,"column":31,"nodeType":"66","messageId":"67","endLine":62,"endColumn":14},{"ruleId":"60","severity":1,"message":"61","line":1,"column":8,"nodeType":"62","messageId":"63","endLine":1,"endColumn":12},"no-native-reassign",["69"],"no-negated-in-lhs",["70"],["69"],["70"],["69"],["70"],"no-unused-vars","'Node' is defined but never used.","Identifier","unusedVar","no-loop-func","Function declared in a loop contains unsafe references to variable(s) 'currNodeCoord', 'currNode', 'currNodeCoord', 'currNodeCoord', 'currNodeCoord', 'currNode', 'currNodeCoord', 'currNode', 'currNode', 'currNodeCoord', 'currNodeCoord', 'currNode', 'currNode', 'currNode', 'currNode', 'currNode'.","ArrowFunctionExpression","unsafeRefs","Function declared in a loop contains unsafe references to variable(s) 'currNode'.","no-global-assign","no-unsafe-negation"]