[{"/home/khai/Documents/school_stuff/2020_fall/advance_algo/MaxFlowVisualizer/max-flow-visualizer/src/App.js":"1","/home/khai/Documents/school_stuff/2020_fall/advance_algo/MaxFlowVisualizer/max-flow-visualizer/src/index.js":"2","/home/khai/Documents/school_stuff/2020_fall/advance_algo/MaxFlowVisualizer/max-flow-visualizer/src/components/Board.js":"3","/home/khai/Documents/school_stuff/2020_fall/advance_algo/MaxFlowVisualizer/max-flow-visualizer/src/LogicalClasses/Node.js":"4","/home/khai/Documents/school_stuff/2020_fall/advance_algo/MaxFlowVisualizer/max-flow-visualizer/src/reportWebVitals.js":"5","/home/khai/Documents/school_stuff/2020_fall/advance_algo/MaxFlowVisualizer/max-flow-visualizer/src/LogicalClasses/Misc.js":"6","/home/khai/Documents/school_stuff/2020_fall/advance_algo/MaxFlowVisualizer/max-flow-visualizer/src/LogicalClasses/GridPathFinder.js":"7","/home/khai/Documents/school_stuff/2020_fall/advance_algo/MaxFlowVisualizer/max-flow-visualizer/src/LogicalClasses/GraphPathFinder.js":"8","/home/khai/Documents/school_stuff/2020_fall/advance_algo/MaxFlowVisualizer/max-flow-visualizer/src/LogicalClasses/NetworkFlow.js":"9","/home/khai/Documents/school_stuff/2020_fall/advance_algo/MaxFlowVisualizer/max-flow-visualizer/src/components/Instruction.js":"10"},{"size":304,"mtime":1606954083032,"results":"11","hashOfConfig":"12"},{"size":500,"mtime":1606525875336,"results":"13","hashOfConfig":"12"},{"size":15478,"mtime":1606954487381,"results":"14","hashOfConfig":"12"},{"size":330,"mtime":1606946375301,"results":"15","hashOfConfig":"12"},{"size":362,"mtime":1606525875336,"results":"16","hashOfConfig":"12"},{"size":839,"mtime":1606905192220,"results":"17","hashOfConfig":"12"},{"size":9650,"mtime":1606954444333,"results":"18","hashOfConfig":"12"},{"size":3379,"mtime":1606945888270,"results":"19","hashOfConfig":"12"},{"size":3417,"mtime":1606944016777,"results":"20","hashOfConfig":"12"},{"size":3243,"mtime":1606953826839,"results":"21","hashOfConfig":"12"},{"filePath":"22","messages":"23","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},"yjnb17",{"filePath":"25","messages":"26","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"27"},{"filePath":"28","messages":"29","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"30"},{"filePath":"31","messages":"32","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"33","messages":"34","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"35"},{"filePath":"36","messages":"37","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"38","messages":"39","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"40"},{"filePath":"41","messages":"42","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"43","messages":"44","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"45","messages":"46","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/home/khai/Documents/school_stuff/2020_fall/advance_algo/MaxFlowVisualizer/max-flow-visualizer/src/App.js",[],["47","48"],"/home/khai/Documents/school_stuff/2020_fall/advance_algo/MaxFlowVisualizer/max-flow-visualizer/src/index.js",[],["49","50"],"/home/khai/Documents/school_stuff/2020_fall/advance_algo/MaxFlowVisualizer/max-flow-visualizer/src/components/Board.js",["51"],"import React from \"react\";\nimport Node from \"../LogicalClasses/Node\";\nimport GridPathFinder from \"../LogicalClasses/GridPathFinder\";\nimport NetworkFlow from \"../LogicalClasses/NetworkFlow\";\nimport Instruction from \"./Instruction\";\nimport {nodeParser, nodeEqual} from \"../LogicalClasses/Misc\";\n\nimport _ from \"lodash\";\nimport \"../styles/Board.css\"\nclass Board extends React.Component {\n    // TODO : INCREMENTAL IMPROVEMENT OF NETWORK\n        // - Implement next button\n        // - highlight augmenting path \n        // - remove node value from previous augmenting path\n        // - fix the infinite loop error somewhere\n   \n    constructor(props) {\n        super(props);\n        this.state = {\n            height : props.height,\n            width :  props.width,\n            gridArray :  this.getInitializeGrid(),\n            nodeType : \"server\",\n            possibleNodeTypes : [\"empty\", \"server\", \"connection\", \"connected-server\"],\n            networkDefinition: \"Format: (x1,y1)->capacity->(x2,y2);\",\n            paths: [], \n            source: \"null\",\n            sink: \"null\",\n            hasNetworkBoard : false,\n            strategy: \"None\",\n            maxFlowReached : false,\n            currentFlow: 0\n        } \n    }\n\n    getInitializeGrid = () => {\n        let gridArr = []\n        for (let row = 0; row < this.props.height; row++) {\n            let currRow = []\n            for (let col = 0; col < this.props.width; col++) {\n                console.log(\"initialized with empty\");\n                currRow.push(new Node(\"empty\", 0, 0));\n            }\n            gridArr.push(currRow);\n        }\n\n        return gridArr;\n    }\n    \n    drawBoard = () => {\n        // draw board from grid\n        let tableRows = [];\n        let idKey;\n        let className;\n        let value;\n        \n        for (let row = 0; row < this.state.height + 1; row++) {\n            let cells = []\n            for (let col = 0; col < this.state.width + 1; col++) {\n                let style = {};\n                // if col = 0, push row number to first item \n                if (col === 0 & row === 0) {\n                    idKey= \"header\";\n                    className = \"board-rows header\";\n                    value = \"X / Y\";\n                }\n                else if (col === 0) {\n                    // at column 0, but a non-zero row, fill in row number\n                    idKey = `rheader-${row}`;\n                    className = \"board-rows rheader\";\n                    value = row - 1;\n                }\n                else if (row === 0) {\n                    idKey = `cheader-${col}`;\n                    className =  \"board-rows cheader\";\n                    value = col - 1;\n                }\n                else {\n                    // push node object into GridArray\n                    let newNode = this.state.gridArray[row-1][col-1];\n                    idKey = `${row - 1}-${col-1}`;\n                    value = \" \";\n                    className = \"board-columns\";\n                    \n                    if (newNode.type !== \"empty\") {\n                        className += ` ${newNode.type}`;\n                        \n                        if (newNode.type === \"connection\") {\n                            style = {backgroundColor: newNode.color};\n                            value = `${newNode.flow}/${newNode.capacity}`;\n                        }\n                        if(newNode.type === \"connected-server\") {\n                            style = {backgroundColor: newNode.color};\n                            value = \"server\";\n                        }\n                        if (newNode.isSource) {\n                            value = \"SOURCE\";\n                        } else if (newNode.isSink) {\n                            value = \"SINK\";\n                        }\n                    }\n\n                    if (newNode.inAugmentedPath) {\n                        // className += \" inPath\";\n                        style.border = \"8px solid coral\";\n                    }\n                }\n               \n                cells.push(<td key = {idKey} id= {idKey} className = {className} style = {style}>{value}</td>);  \n            }\n            idKey = `r${row}`;\n            className = \"board-rows\";\n            value = cells;\n            tableRows.push(<tr key ={idKey} id= {idKey} className = {className}>{value}</tr>); \n        }\n        return (\n                <table className=\"board\">\n                    <tbody>{tableRows}</tbody>\n                </table>\n        );\n    };\n\n    \n    networkDefinitionHandler = (event) => {\n        this.setState({\n            networkDefinition: event.target.value\n        }, ()=> {\n            console.log(this.state.networkDefinition);\n        });\n    }\n    \n    sinkHandler = (event) => {\n        this.setState({\n            sink : event.target.value.trim()\n        }, () => {console.log(this.state.sink)});\n    }\n\n    sourceHandler = (event) => {\n        this.setState({\n            source : event.target.value.trim()\n        }, () => {console.log(this.state.source)});\n    }\n\n    getGeneratedGrid = (event) => {\n        let rawDefinition = this.state.networkDefinition.trim();\n        // get deep copy of gridArray from state\n        let gridArrGen = _.cloneDeep(this.state.gridArray);\n        let pathFinder = new GridPathFinder(gridArrGen, this.state.source, this.state.sink, rawDefinition, \"bfs\");\n\n        let gridPaths  = pathFinder.getGridWithPaths();\n        if (typeof gridPaths === \"string\") {\n            alert(gridPaths);\n            return gridPaths;\n        }\n\n        let grid = gridPaths[0];\n        let paths = gridPaths[1];\n        \n        this.setState({\n            paths: paths\n        });\n    \n        return grid;  \n    }\n\n    generateBoard = (event) => {\n        // clear board first\n        let initializedGrid = this.getInitializeGrid();\n        this.setState({\n            gridArray : initializedGrid\n        }, ()=> {\n            // call back hell lol\n            // will fix later\n            // change to grid with user's network definition\n            let generatedGrid = this.getGeneratedGrid();\n            if (typeof generatedGrid != \"string\") {\n                this.setState({\n                    gridArray: generatedGrid\n                }, () => {\n                    this.setState({\n                        hasNetworkBoard : true\n                    });\n                    return this.drawBoard();\n                }); \n            }\n            \n            \n        });\n    }\n\n    maxFlowBoard = (strategy) => {\n        let searchType = \"dfs\";\n        if (strategy === \"Edmonds-Karp\") {\n            searchType = \"bfs\";\n        }\n            \n        let networkFlow = new NetworkFlow(this.state.gridArray, this.state.paths, this.state.source, this.state.sink, searchType);\n        let augmentingPath = networkFlow.getAugmentingPath();\n        \n        // if no more path, max flow reach\n        if (typeof augmentingPath === \"string\") {\n            alert(augmentingPath);\n            return augmentingPath;\n        }\n    \n        // get deep copy of this.state.gridArray;\n        let improvedGridArray = _.cloneDeep(this.state.gridArray);\n        \n        if (this.state.currentFlow != 0) {\n            // unhighlight previous path\n            for (let r = 0; r < this.state.height; r++) {\n                for (let c = 0; c < this.state.width; c++) {\n                    improvedGridArray[r][c].inAugmentedPath = false;\n                }\n            }\n        }\n        \n        console.log(augmentingPath);\n        let curr = this.state.source;\n        // let parsedCurr = nodeParser(this.state.source, this.state.gridArray.length, this.state.gridArray[0].length);\n        let next = null;\n        let pathsFromCurr = null;\n        let paths = this.state.paths;\n\n        let minResidual = Infinity;\n\n        let forwardEdgesInAugmentingPath = [];\n        let backwardEdgesInAugmentingPath = [];\n\n        let edgeType = null;\n        augmentingPath.forEach((edge)=> {\n            edgeType = edge.edgeType;\n            next = edge.target;\n\n            if (edgeType === \"backward\") {\n                // swap curr and next \n                // since pathsFromCurr only store paths corresponding to forward edges in an augmented graph \n                let tmp = next;\n                next = curr;\n                curr = tmp;\n            }\n            // parse node \"next\" into coordinate representation since nodes stored in paths are in coordinate form\n            // allow easier comparison using helper function nodeEqual\n            let parsedNext = nodeParser(next, this.state.gridArray.length, this.state.gridArray[0].length);\n\n            // allowed augmentation in a flow network at any time \n            // depends on the edge with the smallest flow in the augmenting path of\n            // that respective time's residual network\n            minResidual = Math.min(minResidual, edge.residual);\n            // get all paths from current node\n            pathsFromCurr = paths.get(curr);\n            // find path from current node to target node in grid\n            let path_idx = 0;\n            let foundPath = false;\n            let path = null;\n            while(path_idx < pathsFromCurr.length && !foundPath) {\n                path = pathsFromCurr[path_idx];\n\n                if (nodeEqual(parsedNext, path[path.length - 1])) {\n                    foundPath = true; \n                }\n                path_idx++;\n            }\n            if (edgeType === \"backward\") {\n                // switch back to take on next edge in augmenting path\n                let tmp = next;\n                next = curr;\n                curr = tmp;\n                // since backward edges DECREASES the flow along that edge in the real graph\n                // must store them separately to handle flow decrease.\n                backwardEdgesInAugmentingPath = backwardEdgesInAugmentingPath.concat(path);\n            } else {\n                forwardEdgesInAugmentingPath = forwardEdgesInAugmentingPath.concat(path);\n            }\n            // advance curr to target \n            curr = next;\n        })\n\n        forwardEdgesInAugmentingPath.forEach((node) => {\n            // increase flow of forward edges\n            improvedGridArray[node[0]][node[1]].flow += minResidual;\n            improvedGridArray[node[0]][node[1]].inAugmentedPath = true;\n        });\n\n        backwardEdgesInAugmentingPath.forEach((node) => {\n            // decrease flow of backward edges\n            improvedGridArray[node[0]][node[1]].flow -= minResidual;\n            improvedGridArray[node[0]][node[1]].inAugmentedPath = true;\n        });\n\n\n        return improvedGridArray;   \n    }\n\n    runMaxFlowAlgorithm = (strategy) => {\n        this.setState({\n            strategy: strategy\n        }, ()=> {\n            let grid = this.maxFlowBoard(strategy);\n            if (typeof grid !== \"string\") {\n                let parsedSink = nodeParser(this.state.source, grid.height, grid[0].height);\n                let currFlow = grid[parsedSink[0]][parsedSink[1]].flow;\n\n                this.setState({\n                    gridArray : grid,\n                    currentFlow: currFlow\n                }, ()=> {\n                    return this.drawBoard();\n                }); \n            }\n            else {\n                this.setState({\n                    maxFlowReached : true\n                })\n            }\n        })\n    }\n\n    submitHandler = (event) => {\n        // Form submission automattically rerender/refreshes the page\n        // prevent this behavior to display board\n        event.preventDefault();\n        this.setState({\n            currentFlow : 0,\n            maxFlowReached : false,\n            strategy: \"None\"\n        }, () => {\n            return this.generateBoard();\n        });\n    }\n\n    render() {\n        let board = null;\n        let algoChooser = (\n            <div id=\"algo-chooser\">\n                <h3>The flow through your network may still be improved! Please choose which max flow algorithm you wish to use:</h3>\n                <div className = \"algo-board\">\n                    <div id=\"ford-fulkerson\">\n                        <button onClick={()=> {board = this.runMaxFlowAlgorithm(\"Ford-Fulkerson\")}}>Ford-Fulkerson</button>\n                        <p>Ford Fulkerson finds any arbitary path in the Residual Network and uses such path to augment the flow. It keeps\n                            doing so until there is absolutely no more augmenting path possible! \n                            \n                        </p> \n                        <p>My implementation of \n                            Ford-Fulkerson employs the standard Depth First Search to find the augmenting path.Due to this strategy,\n                            certain network architecture may causes Ford-Fulkerson to runs in exponential time! \n                        </p>\n                        </div>\n                    <div id=\"edmonds-karp\">\n                        <button onClick={()=> {board = this.runMaxFlowAlgorithm(\"Edmonds-Karp\")}}>Edmonds-Karp</button>\n                        <p>Edmonds-Karp improves upon Ford-Fulkerson by not finding any arbitary augmenting path,\n                            but rather the shortest augmenting path in term of the number of nodes it has to travel.\n                        </p> \n                        <p> Thus, Edmonds-Karps uses Breadth First Search to find the augmenting path. The running time \n                            is polynomial in term of the number of nodes and vertices in the network. \n                        </p>\n                    </div>   \n                </div>\n                \n                {this.state.strategy !== \"None\"? (\n                    <div>\n                        <p> You chose {this.state.strategy}</p>\n                    </div>\n                    ): null}\n            </div>\n        );\n\n        let currentFlowReport = (\n            <div id=\"flow-report\">\n                <h2>Current flow through this graph is: </h2>\n                <h1 id=\"flow-value\">{this.state.currentFlow}</h1>\n            </div>\n        );\n\n        return(\n            <article className=\"max-flow-visualizer\">\n                <Instruction></Instruction>\n                <div className=\"board-div\">\n                    <form id=\"network-form\" onSubmit={(event) => {board = this.submitHandler(event)}}>\n                        <label htmlFor=\"network-def\"> Network Definition</label>\n                        <input placeholder=\"Type coordinate of source node using format (x,y)\" onChange={this.sourceHandler}></input>\n                        <input placeholder=\"Type coordinate of sink node using format (x,y)\" onChange={this.sinkHandler}></input>\n                        <textarea name=\"network-def\" placeholder={this.state.networkDefinition} \n                                  onChange={this.networkDefinitionHandler} rows={10}>\n                            </textarea>\n                        <input type=\"submit\" value=\"Submit\"></input>\n                    </form>\n                    {/* Only display algorithm choosing panel while max flow has not been reached */}\n                    {this.state.hasNetworkBoard && !this.state.maxFlowReached? algoChooser: null}\n                    {this.state.hasNetworkBoard? currentFlowReport: null}\n                </div>\n                <div>{board == null? this.drawBoard() : board}</div>\n                \n            </article>\n        )\n    }\n\n\n}\n\nexport default Board;","/home/khai/Documents/school_stuff/2020_fall/advance_algo/MaxFlowVisualizer/max-flow-visualizer/src/LogicalClasses/Node.js",[],"/home/khai/Documents/school_stuff/2020_fall/advance_algo/MaxFlowVisualizer/max-flow-visualizer/src/reportWebVitals.js",[],["52","53"],"/home/khai/Documents/school_stuff/2020_fall/advance_algo/MaxFlowVisualizer/max-flow-visualizer/src/LogicalClasses/Misc.js",[],"/home/khai/Documents/school_stuff/2020_fall/advance_algo/MaxFlowVisualizer/max-flow-visualizer/src/LogicalClasses/GridPathFinder.js",["54","55"],"import Node from \"./Node\";\nimport {getRandomColor, nodeParser, nodeEqual} from \"./Misc\";\nimport _ from \"lodash\";\n\n\nclass GridPathFinder {\n    constructor(gridArray,source, sink, networkDefinition,strategy) {\n        this.gridArray = gridArray;\n        this.gridMaxX = gridArray.length;\n        this.gridMaxY = gridArray[0].length;\n        this.source = source;\n        this.sink = sink\n        this.networkDefinition = networkDefinition;\n        this.strategy = strategy.trim().toLowerCase();\n        this.allowedStrategies = [\"bfs\", \"dfs\"];\n    }\n\n    getGridWithPaths = () => {\n        // process network definition to get sourceTargetDict\n        let graph = this.processNetworkDefinition();\n        console.log(graph);\n        // depending on this.strategy, dispatch to different function \n        if (this.allowedStrategies.includes(this.strategy)) {\n            return this.findPathsOnGrid(this.gridArray, graph, this.strategy);\n        } else {\n            return \"Unknown Pathfinding strategy\";\n        }\n\n    }\n\n    processNetworkDefinition = () => {\n        let networkDef = this.networkDefinition;\n\n        let parsedSource = nodeParser(this.source, this.gridMaxX, this.gridMaxY);\n        let parsedSink = nodeParser(this.sink, this.gridMaxX, this.gridMaxY); \n\n        // if source and sink are not specified, or is in invalid format, return error message\n        if (typeof parsedSource === \"string\" || typeof parsedSink === \"string\") {\n            return \"Error: Invalid Source or Sink node format. Check if your coordinates are in correct format and they are within the dimension of the grid.\";\n        }\n\n        let edgeDefinitions = networkDef.split(\";\").filter(x=>x);\n        // map to keep track of {NodeA : [(NodeB, capacity), (NodeC, capacity) ...]}\n        let graph = new Map();\n        \n        let notHasSource = true;\n        let notHasSink = true;\n\n        edgeDefinitions.forEach(edgeDef => {\n            let edgeDefArr = edgeDef.split(\"->\").filter(x=>x);\n            let serverA = edgeDefArr[0].trim();\n            let capacity = +edgeDefArr[1].trim();\n            let serverB = edgeDefArr[2].trim();\n\n            let parsedA = nodeParser(serverA, this.gridMaxX, this.gridMaxY);\n            let parsedB = nodeParser(serverB, this.gridMaxX, this.gridMaxY);\n\n            if (typeof parsedA === \"string\" || typeof parsedB === \"string\") {\n                let err = \"Error: Invalid network node format. Check if your coordinates are in correct format and they are within the dimension of the grid.\";\n                alert(err);\n                return err;\n            }\n            \n            // if network doesn't have a source nor a sink, it trivially has a flow of 0! \n            if (serverA === this.source || serverB === this.source) {\n                notHasSource = false;\n            }\n            if (serverA === this.sink || serverB === this.sink) {\n                notHasSink = false;\n            }\n            \n            let edge = [serverB, capacity];\n            let currentEdgeList = graph.get(serverA);\n            if (currentEdgeList === undefined) {  \n                currentEdgeList = [edge];\n            } else {\n                currentEdgeList.push(edge);\n            }\n            graph.set(serverA, currentEdgeList);\n        })\n\n        if (notHasSource || notHasSink) {\n            let err = \"Error: Network doesn't have well-defined source or sink. This network trivially has a flow of 0\";\n            alert(err);\n            return err;\n        }\n        return graph;\n    }\n\n    findPathsOnGrid = (gridArray, graph, strategy) => {\n        let currNodeCoord = null;\n        let currNode = null;\n\n        if (typeof graph == \"string\") {\n            let err = \"Error! Not a valid network!\";\n            alert(err);\n            return err;\n        }\n        \n        // keeps track of paths from different sources to their destinations\n        let sourcesPathsList = new Map();\n\n        let parsedSource = nodeParser(this.source,this.gridMaxX,this.gridMaxY);\n        let parsedSink = nodeParser(this.sink,this.gridMaxX, this.gridMaxY);\n\n        for (const [curr, targets] of graph) {\n            let parsedCurr = nodeParser(curr, this.gridMaxX, this.gridMaxY);\n            \n            // add parseCurr to sourcesPathsList with an empty list of paths at first\n            sourcesPathsList.set(curr, []);\n\n            let randomColor = getRandomColor();\n            targets.forEach(target => {\n\n                let targetNode = target[0];\n                let parsedTargetNode = nodeParser(targetNode, this.gridMaxX, this.gridMaxY);\n                let capacity = +target[1];\n                let foundPath = this.pathFinderHelper(gridArray, curr, targetNode, strategy);\n                if (foundPath === \"No Path found\") {\n                    alert(\"No path found between \" + curr + \" and \" + targetNode);\n                    return \"Please redefine your network by spreading the nodes out further\";\n                }\n\n                // add new paths to map\n                let currPathsFromSourceList = sourcesPathsList.get(curr);\n                currPathsFromSourceList.push(_.cloneDeep(foundPath));\n                sourcesPathsList.set(curr, currPathsFromSourceList);\n\n                let i = 0;\n                while (foundPath.length !== 0) {\n                    currNodeCoord = foundPath.shift();\n                    currNode = gridArray[+currNodeCoord[0]][+currNodeCoord[1]]; \n                    // check if currNode is a source or a sink or none\n                    if (nodeEqual(currNodeCoord,parsedSource)) {\n                        currNode.isSource = true;\n                    } else if (nodeEqual(currNodeCoord,parsedSink)) {\n                        currNode.isSink = true;\n                    }\n\n                    if (currNode.type === \"connected-server\" || nodeEqual(currNodeCoord, parsedTargetNode) || nodeEqual(currNodeCoord, parsedCurr)) {\n                        currNode.type = \"connected-server\";\n                    }\n                    else {\n                        currNode.type = \"connection\";\n                        currNode.capacity = capacity;  \n                        currNode.color = randomColor;\n                    }\n                    // nodes from the same source gets the same color including the source itself but not the destination\n                    if (i === 0){\n                        currNode.color = randomColor;\n                    }\n                    i++; \n                }\n            })  \n        }\n        this.gridArray = gridArray;\n        \n        return [gridArray, sourcesPathsList]; \n    }\n\n\n\n    pathFinderHelper(gridArray, source, target, strategy) { \n        let fringe = [source] \n        // parse string representation of a Node to an object\n        let parsedSource = nodeParser(source, this.gridMaxX, this.gridMaxY);\n\n        let currX = +parsedSource[0];\n        let currY = +parsedSource[1];\n\n        // keep track of nodes we already visited\n        let visitedNodes = new Set();\n\n        let currNode;\n        // dictionary to keep track of BFS shortest path tree\n        let parent = new Map();\n\n        parent.set(source, null);\n        visitedNodes.add(source);\n\n        while (fringe.length !== 0) {\n            if (strategy === \"bfs\"){\n                // BFS\n                currNode = fringe.shift();\n            }\n            else {\n                // DFS \n                currNode = fringe.pop();\n            }\n            \n            let parsedNode = nodeParser(currNode, this.gridMaxX, this.gridMaxY);\n            \n            currX = +parsedNode[0];\n            currY = +parsedNode[1];\n            \n            if (currNode === target) {\n                break;\n            }\n            \n            let rightNode = \"(\" + (currX + 1) + \",\" + currY +\")\";\n            let leftNode = \"(\" + (currX  - 1) + \",\" + currY +\")\";\n            let topNode = \"(\" + (currX) + \",\" + (currY + 1) +\")\";\n            let botNode = \"(\" + (currX) + \",\" + (currY - 1) +\")\";\n\n            if ((currX+1) < gridArray.length && !visitedNodes.has(rightNode) && (gridArray[currX + 1][currY].type === \"empty\" || rightNode === target)) {\n                fringe.push(rightNode);\n                parent.set(rightNode, currNode);\n                visitedNodes.add(rightNode);\n            }\n            if ((currX-1) >= 0 && !visitedNodes.has(leftNode) && (gridArray[currX - 1][currY].type === \"empty\"  || leftNode === target)) {\n                fringe.push(leftNode);\n                parent.set(leftNode, currNode);\n                visitedNodes.add(leftNode);\n            }\n            if ((currY + 1) < gridArray[0].length && !visitedNodes.has(topNode) && (gridArray[currX][currY + 1].type === \"empty\"  || topNode === target)) {\n                fringe.push(topNode);\n                parent.set(topNode, currNode);\n                visitedNodes.add(topNode);\n            }\n            if ((currY - 1) >= 0 && !visitedNodes.has(botNode) && (gridArray[currX][currY - 1].type === \"empty\"  || botNode === target) ) {\n                fringe.push(botNode);\n                parent.set(botNode, currNode);\n                visitedNodes.add(botNode);\n\n            }    \n        }\n\n        if (currNode === target) {\n            let path = []\n            // change currNode back from object to its string representation\n            while(currNode !== null) {\n                console.log(\"travelling up!\");\n                path.unshift(nodeParser(currNode, this.gridMaxX, this.gridMaxY));\n                currNode = parent.get(currNode);\n            }\n            return path;\n        }\n        return \"No Path found\";\n    }\n}\n\nexport default GridPathFinder;","/home/khai/Documents/school_stuff/2020_fall/advance_algo/MaxFlowVisualizer/max-flow-visualizer/src/LogicalClasses/GraphPathFinder.js",["56"],"/home/khai/Documents/school_stuff/2020_fall/advance_algo/MaxFlowVisualizer/max-flow-visualizer/src/LogicalClasses/NetworkFlow.js",["57"],"/home/khai/Documents/school_stuff/2020_fall/advance_algo/MaxFlowVisualizer/max-flow-visualizer/src/components/Instruction.js",[],{"ruleId":"58","replacedBy":"59"},{"ruleId":"60","replacedBy":"61"},{"ruleId":"58","replacedBy":"62"},{"ruleId":"60","replacedBy":"63"},{"ruleId":"64","severity":1,"message":"65","line":209,"column":36,"nodeType":"66","messageId":"67","endLine":209,"endColumn":38},{"ruleId":"58","replacedBy":"68"},{"ruleId":"60","replacedBy":"69"},{"ruleId":"70","severity":1,"message":"71","line":1,"column":8,"nodeType":"72","messageId":"73","endLine":1,"endColumn":12},{"ruleId":"74","severity":1,"message":"75","line":113,"column":29,"nodeType":"76","messageId":"77","endLine":154,"endColumn":14},{"ruleId":"74","severity":1,"message":"78","line":49,"column":31,"nodeType":"76","messageId":"77","endLine":62,"endColumn":14},{"ruleId":"70","severity":1,"message":"71","line":1,"column":8,"nodeType":"72","messageId":"73","endLine":1,"endColumn":12},"no-native-reassign",["79"],"no-negated-in-lhs",["80"],["79"],["80"],"eqeqeq","Expected '!==' and instead saw '!='.","BinaryExpression","unexpected",["79"],["80"],"no-unused-vars","'Node' is defined but never used.","Identifier","unusedVar","no-loop-func","Function declared in a loop contains unsafe references to variable(s) 'currNodeCoord', 'currNode', 'currNodeCoord', 'currNodeCoord', 'currNodeCoord', 'currNode', 'currNodeCoord', 'currNode', 'currNode', 'currNodeCoord', 'currNodeCoord', 'currNode', 'currNode', 'currNode', 'currNode', 'currNode'.","ArrowFunctionExpression","unsafeRefs","Function declared in a loop contains unsafe references to variable(s) 'currNode'.","no-global-assign","no-unsafe-negation"]