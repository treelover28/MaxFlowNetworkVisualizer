[{"/home/khai/Documents/school_stuff/2020_fall/advance_algo/MaxFlowVisualizer/max-flow-visualizer/src/App.js":"1","/home/khai/Documents/school_stuff/2020_fall/advance_algo/MaxFlowVisualizer/max-flow-visualizer/src/index.js":"2","/home/khai/Documents/school_stuff/2020_fall/advance_algo/MaxFlowVisualizer/max-flow-visualizer/src/components/Board.js":"3","/home/khai/Documents/school_stuff/2020_fall/advance_algo/MaxFlowVisualizer/max-flow-visualizer/src/LogicalClasses/Node.js":"4","/home/khai/Documents/school_stuff/2020_fall/advance_algo/MaxFlowVisualizer/max-flow-visualizer/src/reportWebVitals.js":"5","/home/khai/Documents/school_stuff/2020_fall/advance_algo/MaxFlowVisualizer/max-flow-visualizer/src/LogicalClasses/Misc.js":"6","/home/khai/Documents/school_stuff/2020_fall/advance_algo/MaxFlowVisualizer/max-flow-visualizer/src/LogicalClasses/GridPathFinder.js":"7","/home/khai/Documents/school_stuff/2020_fall/advance_algo/MaxFlowVisualizer/max-flow-visualizer/src/LogicalClasses/GraphPathFinder.js":"8","/home/khai/Documents/school_stuff/2020_fall/advance_algo/MaxFlowVisualizer/max-flow-visualizer/src/LogicalClasses/NetworkFlow.js":"9","/home/khai/Documents/school_stuff/2020_fall/advance_algo/MaxFlowVisualizer/max-flow-visualizer/src/components/Instruction.js":"10"},{"size":304,"mtime":1606954083032,"results":"11","hashOfConfig":"12"},{"size":500,"mtime":1606525875336,"results":"13","hashOfConfig":"12"},{"size":16066,"mtime":1606957444237,"results":"14","hashOfConfig":"12"},{"size":330,"mtime":1606946375301,"results":"15","hashOfConfig":"12"},{"size":362,"mtime":1606525875336,"results":"16","hashOfConfig":"12"},{"size":839,"mtime":1606946375301,"results":"17","hashOfConfig":"12"},{"size":9650,"mtime":1606954444333,"results":"18","hashOfConfig":"12"},{"size":3379,"mtime":1606945888270,"results":"19","hashOfConfig":"12"},{"size":3417,"mtime":1606946375301,"results":"20","hashOfConfig":"12"},{"size":3695,"mtime":1606958032267,"results":"21","hashOfConfig":"12"},{"filePath":"22","messages":"23","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},"yjnb17",{"filePath":"25","messages":"26","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"27"},{"filePath":"28","messages":"29","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"30","messages":"31","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"32","messages":"33","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"34"},{"filePath":"35","messages":"36","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"37","messages":"38","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"39"},{"filePath":"40","messages":"41","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"42","messages":"43","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"44","messages":"45","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/home/khai/Documents/school_stuff/2020_fall/advance_algo/MaxFlowVisualizer/max-flow-visualizer/src/App.js",[],["46","47"],"/home/khai/Documents/school_stuff/2020_fall/advance_algo/MaxFlowVisualizer/max-flow-visualizer/src/index.js",[],["48","49"],"/home/khai/Documents/school_stuff/2020_fall/advance_algo/MaxFlowVisualizer/max-flow-visualizer/src/components/Board.js",[],"/home/khai/Documents/school_stuff/2020_fall/advance_algo/MaxFlowVisualizer/max-flow-visualizer/src/LogicalClasses/Node.js",[],"/home/khai/Documents/school_stuff/2020_fall/advance_algo/MaxFlowVisualizer/max-flow-visualizer/src/reportWebVitals.js",[],["50","51"],"/home/khai/Documents/school_stuff/2020_fall/advance_algo/MaxFlowVisualizer/max-flow-visualizer/src/LogicalClasses/Misc.js",[],"/home/khai/Documents/school_stuff/2020_fall/advance_algo/MaxFlowVisualizer/max-flow-visualizer/src/LogicalClasses/GridPathFinder.js",["52","53"],"import Node from \"./Node\";\nimport {getRandomColor, nodeParser, nodeEqual} from \"./Misc\";\nimport _ from \"lodash\";\n\n\nclass GridPathFinder {\n    constructor(gridArray,source, sink, networkDefinition,strategy) {\n        this.gridArray = gridArray;\n        this.gridMaxX = gridArray.length;\n        this.gridMaxY = gridArray[0].length;\n        this.source = source;\n        this.sink = sink\n        this.networkDefinition = networkDefinition;\n        this.strategy = strategy.trim().toLowerCase();\n        this.allowedStrategies = [\"bfs\", \"dfs\"];\n    }\n\n    getGridWithPaths = () => {\n        // process network definition to get sourceTargetDict\n        let graph = this.processNetworkDefinition();\n        console.log(graph);\n        // depending on this.strategy, dispatch to different function \n        if (this.allowedStrategies.includes(this.strategy)) {\n            return this.findPathsOnGrid(this.gridArray, graph, this.strategy);\n        } else {\n            return \"Unknown Pathfinding strategy\";\n        }\n\n    }\n\n    processNetworkDefinition = () => {\n        let networkDef = this.networkDefinition;\n\n        let parsedSource = nodeParser(this.source, this.gridMaxX, this.gridMaxY);\n        let parsedSink = nodeParser(this.sink, this.gridMaxX, this.gridMaxY); \n\n        // if source and sink are not specified, or is in invalid format, return error message\n        if (typeof parsedSource === \"string\" || typeof parsedSink === \"string\") {\n            return \"Error: Invalid Source or Sink node format. Check if your coordinates are in correct format and they are within the dimension of the grid.\";\n        }\n\n        let edgeDefinitions = networkDef.split(\";\").filter(x=>x);\n        // map to keep track of {NodeA : [(NodeB, capacity), (NodeC, capacity) ...]}\n        let graph = new Map();\n        \n        let notHasSource = true;\n        let notHasSink = true;\n\n        edgeDefinitions.forEach(edgeDef => {\n            let edgeDefArr = edgeDef.split(\"->\").filter(x=>x);\n            let serverA = edgeDefArr[0].trim();\n            let capacity = +edgeDefArr[1].trim();\n            let serverB = edgeDefArr[2].trim();\n\n            let parsedA = nodeParser(serverA, this.gridMaxX, this.gridMaxY);\n            let parsedB = nodeParser(serverB, this.gridMaxX, this.gridMaxY);\n\n            if (typeof parsedA === \"string\" || typeof parsedB === \"string\") {\n                let err = \"Error: Invalid network node format. Check if your coordinates are in correct format and they are within the dimension of the grid.\";\n                alert(err);\n                return err;\n            }\n            \n            // if network doesn't have a source nor a sink, it trivially has a flow of 0! \n            if (serverA === this.source || serverB === this.source) {\n                notHasSource = false;\n            }\n            if (serverA === this.sink || serverB === this.sink) {\n                notHasSink = false;\n            }\n            \n            let edge = [serverB, capacity];\n            let currentEdgeList = graph.get(serverA);\n            if (currentEdgeList === undefined) {  \n                currentEdgeList = [edge];\n            } else {\n                currentEdgeList.push(edge);\n            }\n            graph.set(serverA, currentEdgeList);\n        })\n\n        if (notHasSource || notHasSink) {\n            let err = \"Error: Network doesn't have well-defined source or sink. This network trivially has a flow of 0\";\n            alert(err);\n            return err;\n        }\n        return graph;\n    }\n\n    findPathsOnGrid = (gridArray, graph, strategy) => {\n        let currNodeCoord = null;\n        let currNode = null;\n\n        if (typeof graph == \"string\") {\n            let err = \"Error! Not a valid network!\";\n            alert(err);\n            return err;\n        }\n        \n        // keeps track of paths from different sources to their destinations\n        let sourcesPathsList = new Map();\n\n        let parsedSource = nodeParser(this.source,this.gridMaxX,this.gridMaxY);\n        let parsedSink = nodeParser(this.sink,this.gridMaxX, this.gridMaxY);\n\n        for (const [curr, targets] of graph) {\n            let parsedCurr = nodeParser(curr, this.gridMaxX, this.gridMaxY);\n            \n            // add parseCurr to sourcesPathsList with an empty list of paths at first\n            sourcesPathsList.set(curr, []);\n\n            let randomColor = getRandomColor();\n            targets.forEach(target => {\n\n                let targetNode = target[0];\n                let parsedTargetNode = nodeParser(targetNode, this.gridMaxX, this.gridMaxY);\n                let capacity = +target[1];\n                let foundPath = this.pathFinderHelper(gridArray, curr, targetNode, strategy);\n                if (foundPath === \"No Path found\") {\n                    alert(\"No path found between \" + curr + \" and \" + targetNode);\n                    return \"Please redefine your network by spreading the nodes out further\";\n                }\n\n                // add new paths to map\n                let currPathsFromSourceList = sourcesPathsList.get(curr);\n                currPathsFromSourceList.push(_.cloneDeep(foundPath));\n                sourcesPathsList.set(curr, currPathsFromSourceList);\n\n                let i = 0;\n                while (foundPath.length !== 0) {\n                    currNodeCoord = foundPath.shift();\n                    currNode = gridArray[+currNodeCoord[0]][+currNodeCoord[1]]; \n                    // check if currNode is a source or a sink or none\n                    if (nodeEqual(currNodeCoord,parsedSource)) {\n                        currNode.isSource = true;\n                    } else if (nodeEqual(currNodeCoord,parsedSink)) {\n                        currNode.isSink = true;\n                    }\n\n                    if (currNode.type === \"connected-server\" || nodeEqual(currNodeCoord, parsedTargetNode) || nodeEqual(currNodeCoord, parsedCurr)) {\n                        currNode.type = \"connected-server\";\n                    }\n                    else {\n                        currNode.type = \"connection\";\n                        currNode.capacity = capacity;  \n                        currNode.color = randomColor;\n                    }\n                    // nodes from the same source gets the same color including the source itself but not the destination\n                    if (i === 0){\n                        currNode.color = randomColor;\n                    }\n                    i++; \n                }\n            })  \n        }\n        this.gridArray = gridArray;\n        \n        return [gridArray, sourcesPathsList]; \n    }\n\n\n\n    pathFinderHelper(gridArray, source, target, strategy) { \n        let fringe = [source] \n        // parse string representation of a Node to an object\n        let parsedSource = nodeParser(source, this.gridMaxX, this.gridMaxY);\n\n        let currX = +parsedSource[0];\n        let currY = +parsedSource[1];\n\n        // keep track of nodes we already visited\n        let visitedNodes = new Set();\n\n        let currNode;\n        // dictionary to keep track of BFS shortest path tree\n        let parent = new Map();\n\n        parent.set(source, null);\n        visitedNodes.add(source);\n\n        while (fringe.length !== 0) {\n            if (strategy === \"bfs\"){\n                // BFS\n                currNode = fringe.shift();\n            }\n            else {\n                // DFS \n                currNode = fringe.pop();\n            }\n            \n            let parsedNode = nodeParser(currNode, this.gridMaxX, this.gridMaxY);\n            \n            currX = +parsedNode[0];\n            currY = +parsedNode[1];\n            \n            if (currNode === target) {\n                break;\n            }\n            \n            let rightNode = \"(\" + (currX + 1) + \",\" + currY +\")\";\n            let leftNode = \"(\" + (currX  - 1) + \",\" + currY +\")\";\n            let topNode = \"(\" + (currX) + \",\" + (currY + 1) +\")\";\n            let botNode = \"(\" + (currX) + \",\" + (currY - 1) +\")\";\n\n            if ((currX+1) < gridArray.length && !visitedNodes.has(rightNode) && (gridArray[currX + 1][currY].type === \"empty\" || rightNode === target)) {\n                fringe.push(rightNode);\n                parent.set(rightNode, currNode);\n                visitedNodes.add(rightNode);\n            }\n            if ((currX-1) >= 0 && !visitedNodes.has(leftNode) && (gridArray[currX - 1][currY].type === \"empty\"  || leftNode === target)) {\n                fringe.push(leftNode);\n                parent.set(leftNode, currNode);\n                visitedNodes.add(leftNode);\n            }\n            if ((currY + 1) < gridArray[0].length && !visitedNodes.has(topNode) && (gridArray[currX][currY + 1].type === \"empty\"  || topNode === target)) {\n                fringe.push(topNode);\n                parent.set(topNode, currNode);\n                visitedNodes.add(topNode);\n            }\n            if ((currY - 1) >= 0 && !visitedNodes.has(botNode) && (gridArray[currX][currY - 1].type === \"empty\"  || botNode === target) ) {\n                fringe.push(botNode);\n                parent.set(botNode, currNode);\n                visitedNodes.add(botNode);\n\n            }    \n        }\n\n        if (currNode === target) {\n            let path = []\n            // change currNode back from object to its string representation\n            while(currNode !== null) {\n                console.log(\"travelling up!\");\n                path.unshift(nodeParser(currNode, this.gridMaxX, this.gridMaxY));\n                currNode = parent.get(currNode);\n            }\n            return path;\n        }\n        return \"No Path found\";\n    }\n}\n\nexport default GridPathFinder;","/home/khai/Documents/school_stuff/2020_fall/advance_algo/MaxFlowVisualizer/max-flow-visualizer/src/LogicalClasses/GraphPathFinder.js",["54"],"/home/khai/Documents/school_stuff/2020_fall/advance_algo/MaxFlowVisualizer/max-flow-visualizer/src/LogicalClasses/NetworkFlow.js",["55"],"/home/khai/Documents/school_stuff/2020_fall/advance_algo/MaxFlowVisualizer/max-flow-visualizer/src/components/Instruction.js",[],{"ruleId":"56","replacedBy":"57"},{"ruleId":"58","replacedBy":"59"},{"ruleId":"56","replacedBy":"60"},{"ruleId":"58","replacedBy":"61"},{"ruleId":"56","replacedBy":"62"},{"ruleId":"58","replacedBy":"63"},{"ruleId":"64","severity":1,"message":"65","line":1,"column":8,"nodeType":"66","messageId":"67","endLine":1,"endColumn":12},{"ruleId":"68","severity":1,"message":"69","line":113,"column":29,"nodeType":"70","messageId":"71","endLine":154,"endColumn":14},{"ruleId":"68","severity":1,"message":"72","line":49,"column":31,"nodeType":"70","messageId":"71","endLine":62,"endColumn":14},{"ruleId":"64","severity":1,"message":"65","line":1,"column":8,"nodeType":"66","messageId":"67","endLine":1,"endColumn":12},"no-native-reassign",["73"],"no-negated-in-lhs",["74"],["73"],["74"],["73"],["74"],"no-unused-vars","'Node' is defined but never used.","Identifier","unusedVar","no-loop-func","Function declared in a loop contains unsafe references to variable(s) 'currNodeCoord', 'currNode', 'currNodeCoord', 'currNodeCoord', 'currNodeCoord', 'currNode', 'currNodeCoord', 'currNode', 'currNode', 'currNodeCoord', 'currNodeCoord', 'currNode', 'currNode', 'currNode', 'currNode', 'currNode'.","ArrowFunctionExpression","unsafeRefs","Function declared in a loop contains unsafe references to variable(s) 'currNode'.","no-global-assign","no-unsafe-negation"]